# 原理浅析
Uniform-cost Search(UCS)的执行过程和BFS十分类似。可以认为BFS是UCS的一种特殊情况。
在BFS中，每一步的步长一致，可以直接将未搜索的节点加入到队列中去。但在步长不一致的情况下会导致我们不能找到最优解，这是就可以使用UCS。
由于每一步的步长不全相同，在搜索时需要维护一个优先队列，每次更新最短的一条路径，一直更新直到搜索到目标点。
（代价函数由自己定义，在最短路问题中，显然可以让代价为两点的距离）

## 其他
在我看到的资料中，为了同时满足

* 不重复更新
* 不错过更短路径

这两个条件，添加了一个是否在当前路径的判断。显然，只要当前的路上没有某个点，那么这个点就可以被更新进来。但是考虑到复杂度，这样做明显不合理。但我不敢确定这是由于文章的作者功力不足还是算法本身就有待改进。
UCS在图上的处理过程和Djstra十分相似，其实，只需要按照Djstra的方式去更新单源的最短路径即可。

# 参考链接
* [【人工智能】Java实现一致代价搜索（Uniform-cost Search,UCS）]


[【人工智能】Java实现一致代价搜索（Uniform-cost Search,UCS）]:<https://blog.csdn.net/obestboy/article/details/86604030>